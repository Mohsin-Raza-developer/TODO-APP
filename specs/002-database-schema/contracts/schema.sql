-- PostgreSQL Database Schema for Multi-User Todo Application
-- Feature: 002-database-schema
-- Date: 2026-01-12
--
-- This is a reference schema showing the complete database structure.
-- Actual migrations are managed by Alembic in backend/alembic/versions/
--
-- Principles Applied:
-- - Database Schema Architect: BIGINT sequences, B-tree indexes, timestamp automation
-- - Multi-User Data Isolation: user_id foreign keys, ON DELETE CASCADE
-- - ID Architect: Sequential BIGSERIAL IDs, never reused
-- - Neon PostgreSQL Serverless Integration: Pooled connection endpoint required

-- ============================================================================
-- USERS TABLE
-- ============================================================================
-- Purpose: Store authenticated users (Better Auth integration)
-- Relationships: Parent of tasks (one-to-many)
-- GDPR: CASCADE deletion removes all user data

CREATE TABLE users (
    -- Primary Key: Better Auth generates string-based UUIDs
    id TEXT PRIMARY KEY,

    -- Email: Login credential, must be unique to prevent duplicate accounts
    email TEXT UNIQUE NOT NULL,

    -- Name: Display name for UI
    name TEXT NOT NULL,

    -- Created At: Account creation timestamp (audit trail)
    -- Database-level DEFAULT ensures value set even without application code
    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

-- Indexes (automatically created by PRIMARY KEY and UNIQUE constraints)
-- - PRIMARY KEY on id (implicit unique B-tree index)
-- - UNIQUE on email (implicit B-tree index)

COMMENT ON TABLE users IS 'Authenticated users (Better Auth integration)';
COMMENT ON COLUMN users.id IS 'User UUID generated by Better Auth';
COMMENT ON COLUMN users.email IS 'Unique email address for login and account recovery';
COMMENT ON COLUMN users.name IS 'Display name shown in UI';
COMMENT ON COLUMN users.created_at IS 'Account creation timestamp (UTC, auto-set by database)';

-- ============================================================================
-- TASKS TABLE
-- ============================================================================
-- Purpose: Store user's todo items with sequential IDs and completion tracking
-- Relationships: Child of users (many-to-one)
-- Performance: Indexed on user_id for O(log n) query performance
-- Security: ON DELETE CASCADE for GDPR compliance

CREATE TABLE tasks (
    -- Primary Key: Sequential BIGINT (ID Architect pattern)
    -- BIGSERIAL = BIGINT + AUTO_INCREMENT (~9.2 quintillion capacity)
    -- Sequence never reuses deleted IDs (monotonically increasing)
    id BIGSERIAL PRIMARY KEY,

    -- Foreign Key: References users.id (data isolation)
    -- NOT NULL: Tasks cannot exist without a user
    -- ON DELETE CASCADE: Deleting user deletes all their tasks (GDPR "right to be forgotten")
    user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,

    -- Title: Task description (1-200 characters, enforced by VARCHAR)
    -- NOT NULL: Title is required
    title VARCHAR(200) NOT NULL,

    -- Description: Optional details (unlimited length)
    -- NULLABLE: Description is optional
    description TEXT,

    -- Completed: Completion status (boolean flag)
    -- DEFAULT FALSE: New tasks are incomplete by default
    completed BOOLEAN NOT NULL DEFAULT FALSE,

    -- Created At: Task creation timestamp (audit trail)
    -- Database-level DEFAULT ensures value set even without application code
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),

    -- Updated At: Last modification timestamp (audit trail)
    -- Database-level DEFAULT sets initial value
    -- UPDATE trigger automatically updates this field on any row modification
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

-- ============================================================================
-- INDEXES
-- ============================================================================

-- Index on user_id for query performance (Database Schema Architect skill)
-- Type: B-tree (PostgreSQL default, optimal for equality and range queries)
-- Purpose: Optimize WHERE user_id = ? queries (most common query pattern)
-- Performance: O(log n) instead of O(n) full table scan
-- Query Pattern: SELECT * FROM tasks WHERE user_id = 'user_123'
-- Expected Performance: <100ms for 100 tasks per user (SC-002)
CREATE INDEX idx_tasks_user_id ON tasks(user_id);

COMMENT ON INDEX idx_tasks_user_id IS 'B-tree index for user_id filtering (O(log n) performance)';

-- ============================================================================
-- TRIGGERS
-- ============================================================================

-- Trigger Function: Auto-update updated_at field on any row modification
-- Type: PL/pgSQL function (PostgreSQL procedural language)
-- Returns: TRIGGER (special return type for trigger functions)
-- Behavior: Sets NEW.updated_at to current timestamp before UPDATE
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();  -- Set updated_at to current timestamp (UTC)
    RETURN NEW;               -- Return modified row
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION update_updated_at_column IS 'Trigger function to auto-update updated_at field';

-- Trigger: Call update_updated_at_column() before every UPDATE on tasks
-- Type: BEFORE UPDATE (modifies row before write)
-- Scope: FOR EACH ROW (fires once per row updated)
-- Effect: Automatically updates updated_at field without application code
CREATE TRIGGER update_tasks_updated_at
    BEFORE UPDATE ON tasks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

COMMENT ON TRIGGER update_tasks_updated_at ON tasks IS 'Auto-update updated_at on any task modification';

-- ============================================================================
-- COMMENTS (Table-Level Documentation)
-- ============================================================================

COMMENT ON TABLE tasks IS 'User todo items with sequential IDs (ID Architect pattern)';
COMMENT ON COLUMN tasks.id IS 'Sequential BIGINT primary key (BIGSERIAL, never reused)';
COMMENT ON COLUMN tasks.user_id IS 'Foreign key to users.id (NOT NULL, ON DELETE CASCADE)';
COMMENT ON COLUMN tasks.title IS 'Task title (1-200 characters, required)';
COMMENT ON COLUMN tasks.description IS 'Optional task details (unlimited length)';
COMMENT ON COLUMN tasks.completed IS 'Completion status (default: FALSE)';
COMMENT ON COLUMN tasks.created_at IS 'Task creation timestamp (UTC, auto-set by database)';
COMMENT ON COLUMN tasks.updated_at IS 'Last modification timestamp (UTC, auto-updated by trigger)';

-- ============================================================================
-- VERIFICATION QUERIES
-- ============================================================================

-- Verify schema created successfully
-- \dt  -- List all tables
-- \d users  -- Describe users table
-- \d tasks  -- Describe tasks table

-- Verify indexes exist
-- SELECT indexname, indexdef FROM pg_indexes WHERE tablename = 'tasks';

-- Verify triggers exist
-- SELECT trigger_name, event_manipulation, action_statement
-- FROM information_schema.triggers
-- WHERE event_object_table = 'tasks';

-- ============================================================================
-- TEST DATA (Optional, for development/testing only)
-- ============================================================================

-- Insert test user
-- INSERT INTO users (id, email, name) VALUES
-- ('test_user_1', 'alice@example.com', 'Alice Johnson');

-- Insert test tasks
-- INSERT INTO tasks (user_id, title, description, completed) VALUES
-- ('test_user_1', 'Buy groceries', 'Milk, eggs, bread', FALSE),
-- ('test_user_1', 'Finish report', 'Q4 financial analysis', FALSE),
-- ('test_user_1', 'Call dentist', NULL, TRUE);

-- Verify CASCADE deletion
-- DELETE FROM users WHERE id = 'test_user_1';
-- SELECT * FROM tasks;  -- Should return empty (all tasks cascade-deleted)

-- ============================================================================
-- PERFORMANCE NOTES
-- ============================================================================

-- Query Performance Targets (SC-002):
-- - User's tasks: SELECT * FROM tasks WHERE user_id = ? → <100ms for 100 tasks
-- - Single task: SELECT * FROM tasks WHERE id = ? AND user_id = ? → <10ms
-- - Task creation: INSERT INTO tasks (...) RETURNING * → <10ms
-- - Task update: UPDATE tasks SET ... WHERE id = ? AND user_id = ? → <20ms
-- - Task deletion: DELETE FROM tasks WHERE id = ? AND user_id = ? → <10ms

-- Index Usage Verification:
-- EXPLAIN ANALYZE SELECT * FROM tasks WHERE user_id = 'test_user_1';
-- Expected: "Index Scan using idx_tasks_user_id on tasks"
-- Cost should be O(log n), not "Seq Scan" (O(n) full table scan)

-- ============================================================================
-- SECURITY NOTES
-- ============================================================================

-- Multi-User Data Isolation:
-- - ALL queries MUST filter by user_id: WHERE user_id = {authenticated_user_id}
-- - Cross-user access prevented by application-level filtering + database constraints
-- - Ownership verification: WHERE id = ? AND user_id = ? (single query)
-- - 404 Not Found for unauthorized access (prevents information leakage, not 403)

-- GDPR Compliance:
-- - ON DELETE CASCADE: Deleting user automatically deletes all their tasks
-- - Right to be forgotten: DELETE FROM users WHERE id = ? (cascade deletes tasks)
-- - Data export: SELECT * FROM tasks WHERE user_id = ? (all user's task data)

-- Connection Security:
-- - Use Neon pooled endpoint: postgresql://...@host-pooler.region.aws.neon.tech/db
-- - SSL/TLS enforced: sslmode=require in connection string
-- - Credentials in environment variables: DATABASE_URL (never hardcode)

-- ============================================================================
-- MIGRATION STRATEGY
-- ============================================================================

-- This schema is managed by Alembic migrations in backend/alembic/versions/
-- To apply this schema:
--   1. Initialize Alembic: alembic init alembic
--   2. Generate migration: alembic revision --autogenerate -m "Initial schema"
--   3. Manually add trigger creation to generated migration (Alembic doesn't detect triggers)
--   4. Apply migration: alembic upgrade head
--   5. Verify: alembic current (should show latest migration)

-- To rollback:
--   alembic downgrade -1  -- Rollback one migration
--   alembic downgrade base  -- Rollback all migrations

-- Future migrations (Phase III+):
--   - Add columns: priority, due_date, tags
--   - Add tables: categories, tags (many-to-many relationships)
--   - Add indexes: (user_id, completed), (user_id, created_at)

-- ============================================================================
-- END OF SCHEMA
-- ============================================================================
